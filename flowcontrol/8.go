/*
Вправа: Цикли та функції
Щоб пограти з функціями та циклами, давайте реалізуємо функцію квадратного кореня: задано число x,
ми хочемо знайти число z, для якого z² найближче дорівнює x.

Комп’ютери зазвичай обчислюють квадратний корінь з x за допомогою циклу. Починаючи з деякого припущення z,
ми можемо скоригувати z залежно від того, наскільки z² близько до x, створюючи краще припущення:

	z -= (z*z - x) / (2*z)

Повторення цього коригування робить припущення все кращим і кращим, доки ми не отримаємо відповідь, яка
буде максимально близькою до фактичного квадратного кореня.

Реалізуйте це у наданій функції Sqrt. Пристойним початковим припущенням для z є 1, незалежно від вхідних
даних. Для початку повторіть обчислення 10 разів і попутно виведіть кожен z. Подивіться, наскільки близько
ви підійшли до відповіді для різних значень x (1, 2, 3, ...) і як швидко покращується припущення.

Підказка: щоб оголосити та ініціалізувати значення з плаваючою комою, задайте йому синтаксис із плаваючою
комою або скористайтеся перетворенням:

	z := 1,0
	z := float64(1)

Далі змініть умову циклу на зупинку, коли значення припинило змінюватися (або змінилося лише на дуже малу
величину). Подивіться, більше чи менше 10 ітерацій. Спробуйте інші початкові припущення для z, наприклад
x або x/2. Наскільки близькі результати вашої функції до math.Sqrt у стандартній бібліотеці?

(Примітка: якщо вас цікавлять деталі алгоритму, то z² − x визначає наскільки далеко z² знаходиться від того
місця, де воно має бути (x), а ділення на 2z є похідною від z², щоб масштабувати, наскільки ми регулюємо
z залежно від того, як швидко змінюється z². Цей загальний підхід називається методом Ньютона. Він добре
працює для багатьох функцій, але особливо добре для квадратного кореня.)
*/
package main

import (
	"fmt"
)

func Sqrt(x float64) float64 {
	
}

func main() {
	fmt.Println(Sqrt(2))
}
